apiVersion: v1
data:
  .meshrc.yaml: |-
    # merger: federation
    sources:
      - name: graphqlMeshK8s
        handler:
          openapi:
            source: /work/swagger.json
            baseUrl: http://mesh-svc:8001/
            skipSchemaValidation: true
        transforms:
          - rename:
              - from: IoK8sApiCoreV1Node
                to: Node
              - from: IoK8sApiCoreV1NodeList
                to: NodeList
              - from: IoK8sApiCoreV1Namespace
                to: Namespace
              - from: IoK8sApiCoreV1NamespaceList
                to: NamespaceList
              - from: IoK8sApiRbacV1ClusterRoleBinding
                to: ClusterRoleBinding
              - from: IoK8sApiRbacV1ClusterRoleBindingList
                to: ClusterRoleBindingList
              - from: IoK8sApiRbacV1ClusterRole
                to: ClusterRole
              - from: IoK8sApiRbacV1ClusterRoleList
                to: ClusterRoleList
              - from: IoK8sApiStorageV1StorageClass
                to: StorageClass
              - from: IoK8sApiStorageV1StorageClassList
                to: StorageClassList
              - from: IoK8sApiAdmissionregistrationV1MutatingWebhookConfiguration
                to: MutatingWebhookConfiguration
              - from: IoK8sApiAdmissionregistrationV1MutatingWebhookConfigurationList
                to: MutatingWebhookConfigurationList
              - from: IoK8sApiAdmissionregistrationV1ValidatingWebhookConfiguration
                to: ValidatingWebhookConfiguration
              - from: IoK8sApiAdmissionregistrationV1ValidatingWebhookConfigurationList
                to: ValidatingWebhookConfigurationList
              - from: IoK8sApiCertificatesV1beta1CertificateSigningRequest
                to: CertificateSigningRequest
              - from: IoK8sApiCertificatesV1beta1CertificateSigningRequestList
                to: CertificateSigningRequestList
              - from: IoK8sApiPolicyV1beta1PodSecurityPolicy
                to: PodSecurityPolicy
              - from: IoK8sApiPolicyV1beta1PodSecurityPolicyList
                to: PodSecurityPolicyList
              - from: IoK8sApiCoreV1ComponentStatus
                to: ComponentStatus
              - from: IoK8sApiCoreV1ComponentStatusList
                to: ComponentStatusList
              - from: IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
                to: CustomResourceDefinition
              - from: IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList
                to: CustomResourceDefinitionList
              - from: IoK8sApiSchedulingV1PriorityClass
                to: PriorityClass
              - from: IoK8sApiSchedulingV1PriorityClassList
                to: PriorityClassList
              - from: IoK8sApiStorageV1CSIDriver
                to: CSIDriver
              - from: IoK8sApiStorageV1CSIDriverList
                to: CSIDriverList
              - from: IoK8sApiStorageV1CSINode
                to: CSINode
              - from: IoK8sApiStorageV1CSINodeList
                to: CSINodeList
              - from: IoK8sApiStorageV1VolumeAttachment
                to: VolumeAttachment
              - from: IoK8sApiStorageV1VolumeAttachmentList
                to: VolumeAttachmentList
              - from: IoK8sApiCoreV1Pod
                to: Pod
              - from: IoK8sApiCoreV1PodList
                to: PodList
              - from: IoK8sApiCoreV1Service
                to: Service
              - from: IoK8sApiCoreV1ServiceList
                to: ServiceList
              - from: IoK8sApiNetworkingV1beta1Ingress
                to: Ingress
              - from: IoK8sApiNetworkingV1beta1IngressList
                to: IngressList
              - from: IoK8sApiAppsV1ReplicaSet
                to: ReplicaSet
              - from: IoK8sApiAppsV1ReplicaSetList
                to: ReplicaSetList
              - from: IoK8sApiAppsV1Deployment
                to: Deployment
              - from: IoK8sApiAppsV1DeploymentList
                to: DeploymentList
              - from: IoK8sApiAppsV1DaemonSet
                to: DaemonSet
              - from: IoK8sApiAppsV1DaemonSetList
                to: DaemonSetList
              - from: IoK8sApiAppsV1StatefulSet
                to: StatefulSet
              - from: IoK8sApiAppsV1StatefulSetList
                to: StatefulSetList
              - from: IoK8sApiCoreV1ReplicationController
                to: ReplicationController
              - from: IoK8sApiCoreV1ReplicationControllerList
                to: ReplicationControllerList
              - from: IoK8sApiAutoscalingV1HorizontalPodAutoscaler
                to: HorizontalPodAutoscaler
              - from: IoK8sApiAutoscalingV1HorizontalPodAutoscalerList
                to: HorizontalPodAutoscalerList
              - from: IoK8sApiBatchV1beta1CronJob
                to: CronJob
              - from: IoK8sApiBatchV1beta1CronJobList
                to: CronJobList
              - from: IoK8sApiBatchV1Job
                to: Job
              - from: IoK8sApiBatchV1JobList
                to: JobList
              - from: IoK8sApiRbacV1RoleBinding
                to: RoleBinding
              - from: IoK8sApiRbacV1RoleBindingList
                to: RoleBindingList
              - from: IoK8sApiRbacV1Role
                to: Role
              - from: IoK8sApiRbacV1RoleList
                to: RoleList
              - from: IoK8sApiCoreV1ServiceAccount
                to: ServiceAccount
              - from: IoK8sApiCoreV1ServiceAccountList
                to: ServiceAccountList
              - from: IoK8sApiCoreV1ResourceQuota
                to: ResourceQuota
              - from: IoK8sApiCoreV1ResourceQuotaList
                to: ResourceQuotaList
              - from: IoK8sApiCoreV1Endpoints
                to: Endpoints
              - from: IoK8sApiCoreV1EndpointsList
                to: EndpointsList
              - from: IoK8sApiAppsV1ControllerRevision
                to: ControllerRevision
              - from: IoK8sApiAppsV1ControllerRevisionList
                to: ControllerRevisionList
              - from: IoK8sApiNetworkingV1NetworkPolicy
                to: NetworkPolicy
              - from: IoK8sApiNetworkingV1NetworkPolicyList
                to: NetworkPolicyList
              - from: IoK8sApiPolicyV1beta1PodDisruptionBudget
                to: PodDisruptionBudget
              - from: IoK8sApiPolicyV1beta1PodDisruptionBudgetList
                to: PodDisruptionBudgetList
              - from: IoK8sApiCoreV1LimitRange
                to: LimitRange
              - from: IoK8sApiCoreV1LimitRangeList
                to: LimitRangeList
              - from: IoK8sApiCoreV1PodTemplate
                to: PodTemplate
              - from: IoK8sApiCoreV1PodTemplateList
                to: PodTemplateList
              - from: IoK8sApiCoreV1Event
                to: Event
              - from: IoK8sApiCoreV1EventList
                to: EventList
              - from: IoK8sApiCoreV1PersistentVolumeClaim
                to: PersistentVolumeClaim
              - from: IoK8sApiCoreV1PersistentVolumeClaimList
                to: PersistentVolumeClaimList
              - from: IoK8sApiCoreV1PersistentVolume
                to: PersistentVolume
              - from: IoK8sApiCoreV1PersistentVolumeList
                to: PersistentVolumeList
              - from: IoK8sApiCoreV1Secret
                to: Secret
              - from: IoK8sApiCoreV1SecretList
                to: SecretList
              - from: IoK8sApiCoreV1ConfigMap
                to: ConfigMap
              - from: IoK8sApiCoreV1ConfigMapList
                to: ConfigMapList

    additionalTypeDefs: |
        interface K8sResourceInterface {
          kind: String
          apiVersion: String
          metadata: IoK8sApimachineryPkgApisMetaV1ObjectMeta
        }
        interface K8sNamespacedResourceInterface {
          namespace: Namespace
        }
        interface K8sEventOwnerInterface {
          events: EventList
        }
        extend type Node implements K8sResourceInterface
        extend type ConfigMap implements K8sResourceInterface
        extend type PersistentVolumeClaim implements K8sResourceInterface
        extend type Secret implements K8sResourceInterface
        union K8sMounted = ConfigMap | PersistentVolume | Secret
        union K8sPodParent = ReplicaSet | DaemonSet | StatefulSet | Node
        extend type Pod implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          parent: K8sPodParent
          connected: ServiceList
          mounting: [K8sMounted]
          namespace: Namespace
          events: EventList
        }
        extend type ReplicaSet implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          parent: Deployment
          children: PodList
          namespace: Namespace
          events: EventList
        }
        extend type Deployment implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          children: ReplicaSetList
          namespace: Namespace
          events: EventList
        }
        extend type Service implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          connecting: PodList
          namespace: Namespace
          events: EventList
        }
        extend type DaemonSet implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          namespace: Namespace
          events: EventList
          children: PodList
        }
        extend type StatefulSet implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          namespace: Namespace
          events: EventList
          children: PodList
        }
        extend type Query {
          # cluster-wide
          nodes(limit: Int, labelSelector: String): NodeList
          namespaces(limit: Int, labelSelector: String): NamespaceList
          clusterrolebindings(limit: Int, labelSelector: String): ClusterRoleBindingList
          clusterroles(limit: Int, labelSelector: String): ClusterRoleList
          storageclasses(limit: Int, labelSelector: String): StorageClassList
          mutatingwebhookconfigurations(limit: Int, labelSelector: String): MutatingWebhookConfigurationList
          validatingwebhookconfigurations(limit: Int, labelSelector: String): ValidatingWebhookConfigurationList
          certificatesigningrequests(limit: Int, labelSelector: String): CertificateSigningRequestList
          podsecuritypolicies(limit: Int, labelSelector: String): PodSecurityPolicyList
          componentstatuses(limit: Int, labelSelector: String): ComponentStatusList
          customresourcedefinitions(limit: Int, labelSelector: String): CustomResourceDefinitionList
          priorityclasses(limit: Int, labelSelector: String): PriorityClassList
          csidrivers(limit: Int, labelSelector: String): CSIDriverList
          csinodes(limit: Int, labelSelector: String): CSINodeList
          volumeattachments(limit: Int, labelSelector: String): VolumeAttachmentList
          # namespaced
          pods(namespace: String!, limit: Int, labelSelector: String): PodList
          services(namespace: String!, limit: Int, labelSelector: String): ServiceList
          ingresses(namespace: String!, limit: Int, labelSelector: String): IngressList
          replicasets(namespace: String!, limit: Int, labelSelector: String): ReplicaSetList
          deployments(namespace: String!, limit: Int, labelSelector: String): DeploymentList
          daemonsets(namespace: String!, limit: Int, labelSelector: String): DaemonSetList
          statefulsets(namespace: String!, limit: Int, labelSelector: String): StatefulSetList
          replicationcontrollers(namespace: String!, limit: Int, labelSelector: String): ReplicationControllerList
          horizontalpodautoscalers(namespace: String!, limit: Int, labelSelector: String): HorizontalPodAutoscalerList
          cronjobs(namespace: String!, limit: Int, labelSelector: String): CronJobList
          jobs(namespace: String!, limit: Int, labelSelector: String): JobList
          rolebindings(namespace: String!, limit: Int, labelSelector: String): RoleBindingList
          roles(namespace: String!, limit: Int, labelSelector: String): RoleList
          serviceaccounts(namespace: String!, limit: Int, labelSelector: String): ServiceAccountList
          resourcequotas(namespace: String!, limit: Int, labelSelector: String): ResourceQuotaList
          endpoints(namespace: String!, limit: Int, labelSelector: String): EndpointsList
          controllerrevisions(namespace: String!, limit: Int, labelSelector: String): ControllerRevisionList
          networkpolicies(namespace: String!, limit: Int, labelSelector: String): NetworkPolicyList
          poddisruptionbudgets(namespace: String!, limit: Int, labelSelector: String): PodDisruptionBudgetList
          limitranges(namespace: String!, limit: Int, labelSelector: String): LimitRangeList
          podtemplates(namespace: String!, limit: Int, labelSelector: String): PodTemplateList
          events(namespace: String!, limit: Int, labelSelector: String): EventList
          persistentvolumeclaims(namespace: String!, limit: Int, labelSelector: String): PersistentVolumeClaimList
          persistentvolumes(namespace: String!, limit: Int, labelSelector: String): PersistentVolumeList
          secrets(namespace: String!, limit: Int, labelSelector: String): SecretList
          configmaps(namespace: String!, limit: Int, labelSelector: String): ConfigMapList
          nos(limit: Int, labelSelector: String): NodeList
          nss(limit: Int, labelSelector: String): NamespaceList
          scs(limit: Int, labelSelector: String): StorageClassList
          csrs(limit: Int, labelSelector: String): CertificateSigningRequestList
          psps(limit: Int, labelSelector: String): PodSecurityPolicyList
          css(limit: Int, labelSelector: String): ComponentStatusList
          crds(limit: Int, labelSelector: String): CustomResourceDefinitionList
          pcs(limit: Int, labelSelector: String): PriorityClassList
          pos(namespace: String!, limit: Int, labelSelector: String): PodList
          svcs(namespace: String!, limit: Int, labelSelector: String): ServiceList
          rss(namespace: String!, limit: Int, labelSelector: String): ReplicaSetList
          deploys(namespace: String!, limit: Int, labelSelector: String): DeploymentList
          pvcs(namespace: String!, limit: Int, labelSelector: String): PersistentVolumeClaimList
          pvs(namespace: String!, limit: Int, labelSelector: String): PersistentVolumeList
          ings(namespace: String!, limit: Int, labelSelector: String): IngressList
          dss(namespace: String!, limit: Int, labelSelector: String): DaemonSetList
          stss(namespace: String!, limit: Int, labelSelector: String): StatefulSetList
          rcs(namespace: String!, limit: Int, labelSelector: String): ReplicationControllerList
          hpas(namespace: String!, limit: Int, labelSelector: String): HorizontalPodAutoscalerList
          cjs(namespace: String!, limit: Int, labelSelector: String): CronJobList
          sas(namespace: String!, limit: Int, labelSelector: String): ServiceAccountList
          quotas(namespace: String!, limit: Int, labelSelector: String): ResourceQuotaList
          eps(namespace: String!, limit: Int, labelSelector: String): EndpointsList
          netpols(namespace: String!, limit: Int, labelSelector: String): NetworkPolicyList
          pdbs(namespace: String!, limit: Int, labelSelector: String): PodDisruptionBudgetList
          limitss(namespace: String!, limit: Int, labelSelector: String): LimitRangeList
          evs(namespace: String!, limit: Int, labelSelector: String): EventList
          cms(namespace: String!, limit: Int, labelSelector: String): ConfigMapList
          # single
          # cluster-wide
          node(name: String, limit: Int, labelSelector: String): Node
          namespace(name: String, limit: Int, labelSelector: String): Namespace
          clusterrolebinding(name: String, limit: Int, labelSelector: String): ClusterRoleBinding
          clusterrole(name: String, limit: Int, labelSelector: String): ClusterRole
          storageclass(name: String, limit: Int, labelSelector: String): StorageClass
          mutatingwebhookconfiguration(name: String, limit: Int, labelSelector: String): MutatingWebhookConfiguration
          validatingwebhookconfiguration(name: String, limit: Int, labelSelector: String): ValidatingWebhookConfiguration
          certificatesigningrequest(name: String, limit: Int, labelSelector: String): CertificateSigningRequest
          podsecuritypolicy(name: String, limit: Int, labelSelector: String): PodSecurityPolicy
          componentstatus(name: String, limit: Int, labelSelector: String): ComponentStatus
          customresourcedefinition(name: String, limit: Int, labelSelector: String): CustomResourceDefinition
          priorityclass(name: String, limit: Int, labelSelector: String): PriorityClass
          csidriver(name: String, limit: Int, labelSelector: String): CSIDriver
          csinode(name: String, limit: Int, labelSelector: String): CSINode
          volumeattachment(name: String, limit: Int, labelSelector: String): VolumeAttachment
          # namespaced
          pod(namespace: String!, name: String, limit: Int, labelSelector: String): Pod
          service(namespace: String!, name: String, limit: Int, labelSelector: String): Service
          ingress(namespace: String!, name: String, limit: Int, labelSelector: String): Ingress
          replicaset(namespace: String!, name: String, limit: Int, labelSelector: String): ReplicaSet
          deployment(namespace: String!, name: String, limit: Int, labelSelector: String): Deployment
          daemonset(namespace: String!, name: String, limit: Int, labelSelector: String): DaemonSet
          statefulset(namespace: String!, name: String, limit: Int, labelSelector: String): StatefulSet
          replicationcontroller(namespace: String!, name: String, limit: Int, labelSelector: String): ReplicationController
          horizontalpodautoscaler(namespace: String!, name: String, limit: Int, labelSelector: String): HorizontalPodAutoscaler
          cronjob(namespace: String!, name: String, limit: Int, labelSelector: String): CronJob
          job(namespace: String!, name: String, limit: Int, labelSelector: String): Job
          rolebinding(namespace: String!, name: String, limit: Int, labelSelector: String): RoleBinding
          role(namespace: String!, name: String, limit: Int, labelSelector: String): Role
          serviceaccount(namespace: String!, name: String, limit: Int, labelSelector: String): ServiceAccount
          resourcequota(namespace: String!, name: String, limit: Int, labelSelector: String): ResourceQuota
          endpoint(namespace: String!, name: String, limit: Int, labelSelector: String): Endpoints
          controllerrevision(namespace: String!, name: String, limit: Int, labelSelector: String): ControllerRevision
          networkpolicy(namespace: String!, name: String, limit: Int, labelSelector: String): NetworkPolicy
          poddisruptionbudget(namespace: String!, name: String, limit: Int, labelSelector: String): PodDisruptionBudget
          limitrange(namespace: String!, name: String, limit: Int, labelSelector: String): LimitRange
          podtemplate(namespace: String!, name: String, limit: Int, labelSelector: String): PodTemplate
          event(namespace: String!, name: String, limit: Int, labelSelector: String): Event
          persistentvolumeclaim(namespace: String!, name: String, limit: Int, labelSelector: String): PersistentVolumeClaim
          persistentvolume(namespace: String!, name: String, limit: Int, labelSelector: String): PersistentVolume
          secret(namespace: String!, name: String, limit: Int, labelSelector: String): Secret
          configmap(namespace: String!, name: String, limit: Int, labelSelector: String): ConfigMap
          no(name: String, limit: Int, labelSelector: String): Node
          ns(name: String, limit: Int, labelSelector: String): Namespace
          sc(name: String, limit: Int, labelSelector: String): StorageClass
          csr(name: String, limit: Int, labelSelector: String): CertificateSigningRequest
          psp(name: String, limit: Int, labelSelector: String): PodSecurityPolicy
          cs(name: String, limit: Int, labelSelector: String): ComponentStatus
          crd(name: String, limit: Int, labelSelector: String): CustomResourceDefinition
          pc(name: String, limit: Int, labelSelector: String): PriorityClass
          po(namespace: String!, name: String, limit: Int, labelSelector: String): Pod
          svc(namespace: String!, name: String, limit: Int, labelSelector: String): Service
          rs(namespace: String!, name: String, limit: Int, labelSelector: String): ReplicaSet
          deploy(namespace: String!, name: String, limit: Int, labelSelector: String): Deployment
          pvc(namespace: String!, name: String, limit: Int, labelSelector: String): PersistentVolumeClaim
          pv(namespace: String!, name: String, limit: Int, labelSelector: String): PersistentVolume
          ing(namespace: String!, name: String, limit: Int, labelSelector: String): Ingress
          ds(namespace: String!, name: String, limit: Int, labelSelector: String): DaemonSet
          sts(namespace: String!, name: String, limit: Int, labelSelector: String): StatefulSet
          rc(namespace: String!, name: String, limit: Int, labelSelector: String): ReplicationController
          hpa(namespace: String!, name: String, limit: Int, labelSelector: String): HorizontalPodAutoscaler
          cj(namespace: String!, name: String, limit: Int, labelSelector: String): CronJob
          sa(namespace: String!, name: String, limit: Int, labelSelector: String): ServiceAccount
          quota(namespace: String!, name: String, limit: Int, labelSelector: String): ResourceQuota
          ep(namespace: String!, name: String, limit: Int, labelSelector: String): Endpoints
          netpol(namespace: String!, name: String, limit: Int, labelSelector: String): NetworkPolicy
          pdb(namespace: String!, name: String, limit: Int, labelSelector: String): PodDisruptionBudget
          limits(namespace: String!, name: String, limit: Int, labelSelector: String): LimitRange
          ev(namespace: String!, name: String, limit: Int, labelSelector: String): Event
          cm(namespace: String!, name: String, limit: Int, labelSelector: String): ConfigMap
        }
    additionalResolvers:
      - ./additional-resolvers.js
        
  example-query.graphql: |-
    query q {
      pods(namespace: "default") {
        items {
          metadata {
            name
          }
          parent {
            # ReplicaSets (Pod's parent)
            ... on ReplicaSet {
              metadata {
                name
              }
              children {
                # Pods (ReplicaSet's children)
                items {
                  metadata {
                    name
                  }
                }
              }
            }
          }
          connected {
            # Services (Pod's connected resources)
            items {
              metadata {
                name
              }
              connecting {
                # Pods (Service's connecting targets)
                items {
                  metadata {
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
    
  init.sh: |-
    #!/bin/bash
    yarn add deepmerge graphql-fields
    curl -L http://mesh-svc:8001/openapi/v2 -o swagger.json
  additional-resolvers.js: |-
    const graphqlFields = require("graphql-fields");
    const merge = require('deepmerge');

    const resources = {
      nodes: ["node", "CoreV1Node"],
      namespaces: ["namespace", "CoreV1Namespace"],
      clusterroles: ["clusterrole", "RbacAuthorizationV1ClusterRole"],
      clusterrolebindings: ["clusterrolebinding", "RbacAuthorizationV1ClusterRoleBinding"],
      storageclasses: ["storageclass", "StorageV1StorageClass"],
      mutatingwebhookconfigurations: ["mutatingwebhookconfiguration", "AdmissionregistrationV1MutatingWebhookConfiguration"],
      validatingwebhookconfigurations: ["validatingwebhookconfiguration", "AdmissionregistrationV1ValidatingWebhookConfiguration"],
      certificatesigningrequests: ["certificatesigningrequest", "CertificatesV1beta1CertificateSigningRequest"],
      podsecuritypolicies: ["podsecuritypolicy", "PolicyV1beta1PodSecurityPolicy"],
      componentstatuses: ["componentstatus", "CoreV1ComponentStatus"],
      customresourcedefinitions: ["customresourcedefinition", "ApiextensionsV1CustomResourceDefinition"],
      priorityclasses: ["priorityclass", "SchedulingV1PriorityClass"],
      csidrivers: ["csidriver", "StorageV1CSIDriver"],
      csinodes: ["csinode", "StorageV1CSINode"],
      volumeattachments: ["volumeattachment", "VolumeAttachment"],
      pods: ["pod", "CoreV1NamespacedPod"],
      services: ["service", "CoreV1NamespacedService"],
      ingresses: ["ingress", "NetworkingV1beta1NamespacedIngress"],
      replicasets: ["replicaset", "AppsV1NamespacedReplicaSet"],
      deployments: ["deployment", "AppsV1NamespacedDeployment"],
      statefulsets: ["statefulset", "AppsV1NamespacedStatefulSet"],
      daemonsets: ["daemonset", "AppsV1NamespacedDaemonSet"],
      replicationcontrollers: ["replicationcontroller", "CoreV1NamespacedReplicationController"],
      horizontalpodautoscalers: ["horizontalpodautoscaler", "AutoscalingV1NamespacedHorizontalPodAutoscaler"],
      cronjobs: ["cronjob", "BatchV1beta1NamespacedCronJob"],
      jobs: ["job", "BatchV1beta1NamespacedJob"],
      rolebindings: ["rolebinding", "RbacAuthorizationV1NamespacedRoleBinding"],
      roles: ["role", "RbacAuthorizationV1NamespacedRole"],
      serviceaccounts: ["serviceaccount", "CoreV1NamespacedServiceAccount"],
      resourcequotas: ["resourcequota", "CoreV1NamespacedResourceQuota"],
      endpoints: ["endpoint", "CoreV1NamespacedEndpoints"],
      controllerrevisions: ["controllerrevision", "AppsV1ControllerRevisionList"],
      networkpolicies: ["networkpolicy", "NetworkingV1NamespacedNetworkPolicy"],
      poddisruptionbudgets: ["poddisruptionbudget", "PolicyV1beta1NamespacedPodDisruptionBudget"],
      limitranges: ["limitrange", "CoreV1NamespacedLimitRange"],
      podtemplates: ["podtemplate", "CoreV1NamespacedPodTemplate"],
      events: ["event", "CoreV1NamespacedEvent"],
      persistentvolumeclaims: ["persistentvolumeclaim", "CoreV1NamespacedPersistentVolumeClaim"],
      persistentvolumes: ["persistentvolume", "CoreV1NamespacedPersistentVolume"], 
      secrets: ["secret", "CoreV1NamespacedSecret"],
      configmaps: ["configmap", "CoreV1NamespacedConfigMap"]
    };

    const abbreviations = {
      nodes: "no",
      namespaces: "ns",
      storageclasses: "sc",
      certificatesigningrequests: "csr",
      podsecuritypolicies: "psp",
      componentstatuses: "cs",
      customresourcedefinitions: "crd",
      priorityclasses: "pc",
      pods: "po",
      services: "svc",
      replicasets: "rs",
      deployments: "deploy",
      persistentvolumeclaims: "pvc",
      persistentvolumes: "pv",
      ingresses: "ing",
      statefulsets: "sts",
      daemonsets: "ds",
      replicationcontrollers: "rc",
      horizontalpodautoscalers: "hpa",
      cronjobs: "cj",
      serviceaccounts: "sa",
      resourcequotas: "quota",
      endpoints: "ep",
      networkpolicies: "netpol",
      poddisruptionbudgets: "pdb",
      limitranges: "limits",
      events: "ev",
      configmaps: "cm"
    };


    const kindmap = {
      Node: "nodes",
      Namespace: "namespaces",
      ClusterRoleBinding: "clusterrolebindings",
      "ClusterRole": "clusterroles",
      StorageClass: "storageclasses",
      MutatingWebhookConfiguration: "mutatingwebhookconfigurations",
      ValidatingWebhookConfiguration: "validatingwebhookconfigurations",
      CertificateSigningRequest: "certificatesigningrequests",
      PodSecurityPolicy: "podsecuritypolicies",
      ComponentStatus: "componentstatuses",
      CustomResourceDefinition: "customresourcedefinitions",
      PriorityClass: "priorityclasses",
      CSIDriver: "csidrivers",
      CSINode: "csinodes",
      VolumeAttachment: "volumeattachments",
      NamespacedPod: "pods",
      Service: "services",
      Ingress: "ingresses",
      ReplicaSet: "replicasets",
      Deployment: "deployments",
      StatefulSet: "statefulsets",
      DaemonSet: "daemonsets",
      ReplicationController: "replicationcontrollers",
      HorizontalPodAutoscale: "horizontalpodautoscalers",
      CronJob: "cronjobs",
      Job: "jobs",
      RoleBinding: "rolebindings",
      Role: "roles",
      ServiceAccount: "serviceaccounts",
      ResourceQuota: "resourcequotas",
      Endpoints: "endpoints",
      ControllerRevisionList: "controllerrevisions",
      NetworkPolicy: "networkpolicies",
      PodDisruptionBudget: "poddisruptionbudgets",
      LimitRange: "limitranges",
      PodTemplate: "podtemplates",
      Event: "events",
      PersistentVolumeClaim: "persistentvolumeclaims",
      PersistentVolume: "persistentvolumes", 
      Secret: "secrets",
      ConfigMap: "configmaps"
    }

    const getListFuncName = resource => "list"+resources[resource][1];
    const getReadFuncName = resource => "read"+resources[resource][1];
    const getSingleName = resource => resources[resource][0];
    const getReadFuncNameFromKind = kind => getReadFuncName(kindmap[kind]);

    const createParentResolver = (resourcelist) => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        const obj_name = obj.metadata && obj.metadata.name;
        var namespace = obj.metadata && obj.metadata.namespace;
        var ownerReferences = obj.metadata && obj.metadata.ownerReferences;
        if((!ownerReferences) ||(!ownerReferences.length) || (!namespace)) {
          console.log("createParentResolver", obj_name, "No ownerReferences or namespace");
          return null;
        }
        var name = ownerReferences[0].name;
        const kind = ownerReferences[0].kind;

        var resolverRequirements = { items: {metadata: { name: true, namespace: true, labels: true, ownerReferences: {name: true}}}};
        var mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };

        const readfn = getReadFuncNameFromKind(kind);
        var _function = graphqlMeshK8s.api[readfn];
        var values = await _function({ name, namespace });
        return values;
      };
      var selectionSet = `{ metadata { name namespace ownerReferences { name kind }}}`;
      return { resolve, selectionSet };
    }
    const createChildrenResolver = (resource) => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createChildrenResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var name = obj.metadata && obj.metadata.name;
        if((!name) || (!namespace)) {
          console.log("createChildrenResolver", name, "No name or namespace")
          return { items: [] };
        }
        //console.log(name, namespace);
        var resolverRequirements = { items: {metadata: { name: true, namespace: true, labels: true, ownerReferences: {name: true}}}};
        var mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };
        //console.log("createChildrenResolver", JSON.stringify(mergedFields));

        const listfn = getListFuncName(resource);
        //console.log("createChildrenResolver", "listfunction", listfn);
        var _function = graphqlMeshK8s.api[listfn];
        var list = await _function({ namespace }, mergedFields);
        //console.log("children base", JSON.stringify(list.items));
        var returnItems = list.items.filter(elem => {
          var ownerReferences = elem.metadata && elem.metadata.ownerReferences;
          if((!ownerReferences) || (!ownerReferences.length)) {
            return false;
          }
          return name == ownerReferences[0].nameStringNonNull; //TOBE: this must be [0].name
        }); 
        list.items = returnItems;
        //console.log(list);
        return list;
      };
      var selectionSet = `{ metadata {name namespace}}`;
      return { resolve, selectionSet };
    }
    const createConnectingResolver = (resource) => {
      var resolve = async (obj, args, { graphqlMeshK8s }, info) => {
        console.log("createConnectingResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var selector = obj.spec && obj.spec.selector;
        if((!selector) || (!namespace)) {
          console.log("createConnectingResolver FAILED: ", "selector", selector, "namespace", namespace);
          return { items: [] };
        }

        const listfn = getListFuncName(resource);
        var _function = graphqlMeshK8s.api[listfn];
        //var labelSelector = Object.keys(selector).map(key => key+"="+selector[key]).join(",");
        var resolverRequirements = { items: { metadata: {name: true, namespace: true, labels: true, ownerReferences: {name: true}}}};
        var mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };
        console.log(JSON.stringify(mergedFields));
        var list = await _function({ namespace }, mergedFields);
        console.log("connecting base", JSON.stringify(list.items));
        //console.log("selector", selector);
        var returnItems = list.items.filter(elem => {
          var labels = elem.metadata.labels;
          return Object.keys(selector).reduce((result, key) => {
            return result && (selector[key] == labels[key])
          }, true)
        });
        list.items = returnItems;
        return list;
      }
      var selectionSet = `{ metadata { name namespace } spec {selector} }`;
      return { resolve, selectionSet };
    }
    const createConnectedResolver = (resource) => {
      var resolve = async (obj, args, { graphqlMeshK8s }, info) => {
        console.log("createConnectedResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var labels = obj.metadata && obj.metadata.labels;
        if((!labels) || (!namespace)) {
          return { items: [] };
        }

        const listfn = getListFuncName(resource);
        var _function = graphqlMeshK8s.api[listfn];
        var resolverRequirements = { items: {metadata: {name: true, namespace: true}, spec: {selector: true }}};
        var mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };
        var list = await _function({ namespace }, mergedFields);
        console.log("connected base", JSON.stringify(list.items));
        var returnItems = list.items.filter(elem => {
          var selector = elem.spec && elem.spec.selector;
          //console.log("selector", selector);
          if(!selector) {
            return false;
          }
          return Object.keys(selector).reduce((result, key) => {
            return result && (selector[key] == labels[key])
          }, true)
        });
        list.items = returnItems;
        return list;
      }
      var selectionSet = `{ metadata { name namespace labels }}`;
      return { resolve, selectionSet };
    }
    const createMountingResolver = () => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createMountingResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var volumes = obj.spec && obj.spec.volumes;
        if((!volumes) ||(!volumes.length) || (!namespace)) {
          return [];
        }
        var promises = volumes.map(elem => {
          if(elem.configMap) {
            return graphqlMeshK8s.api.readCoreV1NamespacedConfigMap({name: elem.configMap.name, namespace });
          } else if(elem.persistentVolumeClaim) {
            return graphqlMeshK8s.api.readCoreV1NamespacedPersistentVolumeClaim({name: elem.persistentVolumeClaim.claimName, namespace});
          } else if(elem.secret) {
            return graphqlMeshK8s.api.readCoreV1NamespacedSecret({name: elem.secret.secretName, namespace});
          }
        }).filter(elem => elem != null);
        return await Promise.all(promises);
      };
      var selectionSet = `{ metadata { name namespace } spec {volumes {configMap {name} persistentVolumeClaim {claimName} secret {secretName}}}}`;
      return { resolve, selectionSet };
    }
    const createEventResolver = () => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createEventResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var name = obj.metadata && obj.metadata.name;
        var kind = obj.kind;
        //console.log(namespace, name, kind);
        if((!name) /*|| (!kind)*/ || (!namespace)) {
          return { items: [] };
        }
        const resolverRequirements = { items: { metadata: {name: true, namespace: true}, involvedObject: { kind: true, name: true }}};
        const mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };
        const events = await graphqlMeshK8s.api.listCoreV1NamespacedEvent({ namespace }, mergedFields);
        var returnEvents = events.items.filter(elem => {
          var involvedObject = elem.involvedObject;
          console.log(involvedObject);
          return (involvedObject.name == name) /*&& (involvedObject.kind == kind)*/;
        });
        events.items = returnEvents;
        return events;
      };
      var selectionSet = `{ kind metadata { namespace name }}`;
      return { resolve, selectionSet };
    }
    const createNamespaceResolver = () => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createNamespaceResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        if(!namespace) {
          return [];
        }
        return await graphqlMeshK8s.api.readCoreV1Namespace({ name: namespace });
      };
      var selectionSet = `{ metadata { namespace }}`;
      return { resolve, selectionSet };
    }

    const createRootResolverMultiple = (resource) => {
      const listfn = getListFuncName(resource);
      return async (obj, args, { graphqlMeshK8s }, info) => {
        return await graphqlMeshK8s.api[listfn](args);
      };
    }

    const createRootResolverSingle = (resource) => {
      const readfn = getReadFuncName(resource);
      return async (obj, args, { graphqlMeshK8s }, info) => {
        const value = await graphqlMeshK8s.api[readfn](args  /*, {fields}*/);
        console.log(JSON.stringify(value));
        return value;
      };
    }
    const resolvers = {
      Pod: {
        parent: createParentResolver("replicasets"),
        connected: createConnectedResolver("services"),
        mounting: createMountingResolver(),
        namespace: createNamespaceResolver(),
        events: createEventResolver()

      },
      ReplicaSet: {
        parent: createParentResolver("deployments"),
        children: createChildrenResolver("pods"),
        namespace: createNamespaceResolver(),
        events: createEventResolver()
      },
      StatefulSet: {
        children: createChildrenResolver("pods"),
        namespace: createNamespaceResolver(),
        events: createEventResolver()
      },
      DaemonSet: {
        children: createChildrenResolver("pods"),
        namespace: createNamespaceResolver(),
        events: createEventResolver()
      },
      Deployment: {
        children: createChildrenResolver("replicasets"),
        namespace: createNamespaceResolver(),
        events: createEventResolver()
      },
      Service: {
        connecting: createConnectingResolver("pods"),
        namespace: createNamespaceResolver(),
        events: createEventResolver()
      },
      K8sMounted: {
        __resolveType(obj, context, info){
          if(obj.kind == "ConfigMap"){
            return 'ConfigMap';
          }

          if(obj.kind == "PersistentVolumeClaim"){
            return 'PersistentVolumeClaim';
          }

          if(obj.kind == "Secret"){
            return 'Secret';
          }
          return null;
        }
      },
      K8sPodParent: {
        __resolveType(obj, context, info){
          if(obj.kind == "ReplicaSet"){
            return 'ReplicaSet';
          }

          if(obj.kind == "DaemonSet"){
            return 'DaemonSet';
          }

          if(obj.kind == "StatefulSet"){
            return 'StatefulSet';
          }

          if(obj.kind == "Node"){
            return 'Node';
          }
          return null;
        }
      }
    };
    var addonQueryResolver = {};
    for(rscs in resources) {
      addonQueryResolver[rscs] = createRootResolverMultiple(rscs);
      addonQueryResolver[getSingleName(rscs)] = createRootResolverSingle(rscs);
    }
    for(key in abbreviations) {
      addonQueryResolver[abbreviations[key]+'s'] = createRootResolverMultiple(key);
      addonQueryResolver[abbreviations[key]] = createRootResolverSingle(key);
    }
    resolvers.Query = addonQueryResolver;
    module.exports = { resolvers };
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: meshrc-cm
  namespace: default
