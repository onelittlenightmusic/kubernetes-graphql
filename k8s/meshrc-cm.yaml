apiVersion: v1
data:
  .meshrc.yaml: |-
    # merger: federation
    sources:
      - name: graphqlMeshK8s
        handler:
          openapi:
            source: /work/swagger.json
            baseUrl: http://mesh-svc:8001/
            skipSchemaValidation: true
        # transforms:
        # - federation: 
        #     types:
        #     - name: Query
        #       config:
        #         extend: true
        #     - name: IoK8sCoreV1Pod
        #       config:
        #         extend: true
        #         keyFields:
        #             - metadata.name
        #         resolveReference: ./childResolveReference.js
        # transforms:
        #   - extend: |
        #       extend type IoK8sApiCoreV1Pod {
        #         parent: IoK8sApiAppsV1ReplicaSet
        #         connected: [IoK8sApiCoreV1Service]
        #       }
        #       extend type IoK8sApiAppsV1ReplicaSet {
        #         parent: IoK8sApiAppsV1Deployment
        #         children: [IoK8sApiCoreV1Pod]
        #       }
        #       extend type IoK8sApiAppsV1Deployment {
        #         children: [IoK8sApiAppsV1ReplicaSet]
        #       }
        #       extend type IoK8sApiCoreV1Service {
        #         connecting: [IoK8sApiCoreV1Pod]
        #       }
    additionalTypeDefs: |
        extend type IoK8sApiCoreV1Pod {
          parent: IoK8sApiAppsV1ReplicaSet
          connected: IoK8sApiCoreV1ServiceList
        }
        extend type IoK8sApiAppsV1ReplicaSet {
          parent: IoK8sApiAppsV1Deployment
          children: IoK8sApiCoreV1PodList
        }
        extend type IoK8sApiAppsV1Deployment {
          children: IoK8sApiAppsV1ReplicaSetList
        }
        extend type IoK8sApiCoreV1Service {
          connecting: IoK8sApiCoreV1PodList
        }
        extend type Query {
          pods(namespace: String!): [IoK8sApiCoreV1Pod]
        }
    additionalResolvers:
      - ./additional-resolvers.js
        
  example-query.graphql: |-
    query q {
      listCoreV1NamespacedPod(namespace: "default") {
        items {
          metadata {
            name
          }
          parent {
            parent {
              metadata {
                name
              }
            }
            children {
              items {
                metadata {
                  name
                  ownerReferences {
                    name
                  }
                }
              }
            }
          }
          connected {
            items {
              metadata {
                name
              }
              spec {
                selector
              }
              connecting {
                items {
                  metadata {
                    name
                    labels
                  }
                }
              }
            }
          }
        }
      }
    }
    
  init.sh: |-
    #!/bin/bash
    curl -L http://mesh-svc:8001/openapi/v2 -o swagger.json
  additional-resolvers.js: |-
    const createParentResolver = (readfn) => {
      var resolve = async (obj, args, {graphqlMeshK8s}) => {
        console.log("createParentResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var ownerReferences = obj.metadata && obj.metadata.ownerReferences;
        if((!ownerReferences) ||(!ownerReferences.length) || (!namespace)) {
          return null;
        }
        var name = ownerReferences[0].name;
        var _function = graphqlMeshK8s.api[readfn];
        var values = await _function({ name, namespace });
        return values;
      };
      var selectionSet = `{ metadata { name namespace ownerReferences { name }}}`;
      return { resolve, selectionSet };
    }
    const createChildrenResolver = (listfn) => {
      var resolve = async (obj, args, {graphqlMeshK8s}) => {
        console.log("createChildrenResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var name = obj.metadata && obj.metadata.name;
        if((!name) || (!namespace)) {
          return null;
        }
        console.log(name, namespace);
        var _function = graphqlMeshK8s.api[listfn];
        var list = await _function({ namespace }, { fields: { items: {metadata: { labels: true, ownerReferences: {name: true}}}}});
        console.log("children base", JSON.stringify(list.items));
        var returnItems = list.items.filter(elem => {
          var ownerReferences = elem.metadata && elem.metadata.ownerReferences;
          if((!ownerReferences) || (!ownerReferences.length)) {
            return false;
          }
          return name == ownerReferences[0].name;
        }); 
        list.items = returnItems;
        //console.log(list);
        return list;
      };
      var selectionSet = `{ metadata {name namespace}}`;
      return { resolve, selectionSet };
    }
    const createConnectingResolver = (listfn) => {
      var resolve = async (obj, args, { graphqlMeshK8s }) => {
        console.log("createConnectingResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var selector = obj.spec && obj.spec.selector;
        if((!selector) || (!namespace)) {
          return [];
        }
        var _function = graphqlMeshK8s.api[listfn];
        //var labelSelector = Object.keys(selector).map(key => key+"="+selector[key]).join(",");
        var list = await _function({ namespace }, { fields: { items: { metadata: {labels: true}}}});
        console.log("connecting base", JSON.stringify(list.items));
        //console.log("selector", selector);
        var returnItems = list.items.filter(elem => {
          var labels = elem.metadata.labels;
          return Object.keys(selector).reduce((result, key) => {
            return result && (selector[key] == labels[key])
          }, true)
        });
        list.items = returnItems;
        return list;
      }
      var selectionSet = `{ metadata { name namespace } spec {selector} }`;
      return { resolve, selectionSet };
    }
    const createConnectedResolver = (listfn) => {
      var resolve = async (obj, args, { graphqlMeshK8s }) => {
        console.log("createConnectedResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var labels = obj.metadata && obj.metadata.labels;
        if((!labels) || (!namespace)) {
          return [];
        }
        var _function = graphqlMeshK8s.api[listfn];
        var list = await _function({ namespace }, { selectionSet: `{ items {spec {selector }}}`, depth: 4});
        console.log("connected base", JSON.stringify(list.items));
        var returnItems = list.items.filter(elem => {
          var selector = elem.spec && elem.spec.selector;
          //console.log("selector", selector);
          if(!selector) {
            return false;
          }
          return Object.keys(selector).reduce((result, key) => {
            return result && (selector[key] == labels[key])
          }, true)
        });
        list.items = returnItems;
        return list;
      }
      var selectionSet = `{ metadata { name namespace labels }}`;
      return { resolve, selectionSet };
    }
    const resolvers = {
      IoK8sApiCoreV1Pod: {
        parent: createParentResolver("readAppsV1NamespacedReplicaSet"),
        connected: createConnectedResolver("listCoreV1NamespacedService")
      },
      IoK8sApiAppsV1ReplicaSet: {
        parent: createParentResolver("readAppsV1NamespacedDeployment"),
        children: createChildrenResolver("listCoreV1NamespacedPod")
      },
      IoK8sApiAppsV1Deployment: {
        children: createChildrenResolver("listAppsV1NamespacedReplicaSet")
      },
      IoK8sApiCoreV1Service: {
        connecting: createConnectingResolver("listCoreV1NamespacedPod")
      },
      Query: {
        pods: async (obj, {namespace}, { graphqlMeshK8s }) => {
          var { items } = await graphqlMeshK8s.api.listCoreV1NamespacedPod({namespace});
          return items;
        }
      }
    };
    module.exports = { resolvers };
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: meshrc-cm
  namespace: default
