apiVersion: v1
data:
  .meshrc.yaml: |-
    # merger: federation
    sources:
      - name: graphqlMeshK8s
        handler:
          openapi:
            source: /work/swagger.json
            baseUrl: http://mesh-svc:8001/
            skipSchemaValidation: true
    additionalTypeDefs: |
        interface K8sResourceInterface {
          kind: String
          apiVersion: String
          metadata: IoK8sApimachineryPkgApisMetaV1ObjectMeta
        }
        interface K8sNamespacedResourceInterface {
          namespace: IoK8sApiCoreV1Namespace
        }
        interface K8sEventOwnerInterface {
          events: IoK8sApiCoreV1EventList
        }
        extend type IoK8sApiCoreV1ConfigMap implements K8sResourceInterface
        extend type IoK8sApiCoreV1PersistentVolumeClaim implements K8sResourceInterface
        extend type IoK8sApiCoreV1Secret implements K8sResourceInterface
        extend type IoK8sApiCoreV1Pod implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          parent: IoK8sApiAppsV1ReplicaSet
          connected: IoK8sApiCoreV1ServiceList
          mounting: [K8sResourceInterface]
          namespace: IoK8sApiCoreV1Namespace
          events: IoK8sApiCoreV1EventList
        }
        extend type IoK8sApiAppsV1ReplicaSet implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          parent: IoK8sApiAppsV1Deployment
          children: IoK8sApiCoreV1PodList
          namespace: IoK8sApiCoreV1Namespace
          events: IoK8sApiCoreV1EventList
        }
        extend type IoK8sApiAppsV1Deployment implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          children: IoK8sApiAppsV1ReplicaSetList
          namespace: IoK8sApiCoreV1Namespace
          events: IoK8sApiCoreV1EventList
        }
        extend type IoK8sApiCoreV1Service implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          connecting: IoK8sApiCoreV1PodList
          namespace: IoK8sApiCoreV1Namespace
          events: IoK8sApiCoreV1EventList
        }
        extend type Query {
          # cluster-wide
          nodes(name: String): IoK8sApiCoreV1NodeList
          namespaces(name: String): IoK8sApiCoreV1NamespaceList
          clusterrolebindings(name: String): IoK8sApiRbacV1ClusterRoleBindingList
          clusterroles(name: String): IoK8sApiRbacV1ClusterRoleList
          storageclasses(name: String): IoK8sApiStorageV1StorageClassList
          mutatingwebhookconfigurations(name: String): IoK8sApiAdmissionregistrationV1MutatingWebhookConfigurationList
          validatingwebhookconfigurations(name: String): IoK8sApiAdmissionregistrationV1ValidatingWebhookConfigurationList
          certificatesigningrequests(name: String): IoK8sApiCertificatesV1beta1CertificateSigningRequestList
          podsecuritypolicies(name: String): IoK8sApiPolicyV1beta1PodSecurityPolicyList
          componentstatuses(name: String): IoK8sApiCoreV1ComponentStatusList
          customresourcedefinitions(name: String): IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList
          priorityclasses(name: String): IoK8sApiSchedulingV1PriorityClassList
          csidrivers(name: String): IoK8sApiStorageV1CSIDriverList
          csinodes(name: String): IoK8sApiStorageV1CSINodeList
          volumeattachments(name: String): IoK8sApiStorageV1VolumeAttachmentList
          # namespaced
          pods(namespace: String!, name: String): IoK8sApiCoreV1PodList
          services(namespace: String!, name: String): IoK8sApiCoreV1ServiceList
          ingresses(namespace: String!, name: String): IoK8sApiNetworkingV1beta1IngressClassList
          replicasets(namespace: String!, name: String): IoK8sApiAppsV1ReplicaSetList
          deployments(namespace: String!, name: String): IoK8sApiAppsV1Deployment
          daemonsets(namespace: String!, name: String): IoK8sApiAppsV1DaemonSetList
          statefulsets(namespace: String!, name: String): IoK8sApiAppsV1StatefulSetList
          replicationcontrollers(namespace: String!, name: String): IoK8sApiCoreV1ReplicationControllerList
          horizontalpodautoscalers(namespace: String!, name: String): IoK8sApiAutoscalingV1HorizontalPodAutoscalerList
          cronjobs(namespace: String!, name: String): IoK8sApiBatchV1beta1CronJobList
          jobs(namespace: String!, name: String): IoK8sApiBatchV1JobList
          rolebindings(namespace: String!, name: String): IoK8sApiRbacV1RoleBindingList
          roles(namespace: String!, name: String): IoK8sApiRbacV1RoleList
          serviceaccounts(namespace: String!, name: String): IoK8sApiCoreV1ServiceAccountList
          resourcequotas(namespace: String!, name: String): IoK8sApiCoreV1ResourceQuotaList
          endpoints(namespace: String!, name: String): IoK8sApiCoreV1EndpointsList
          controllerrevisions(namespace: String!, name: String): IoK8sApiAppsV1ControllerRevisionList
          networkpolicies(namespace: String!, name: String): IoK8sApiNetworkingV1NetworkPolicyList
          poddisruptionbudgets(namespace: String!, name: String): IoK8sApiPolicyV1beta1PodDisruptionBudgetList
          limitranges(namespace: String!, name: String): IoK8sApiCoreV1LimitRangeList
          podtemplates(namespace: String!, name: String): IoK8sApiCoreV1PodTemplateList
          events(namespace: String!, name: String): IoK8sApiCoreV1EventList
          persistentvolumeclaims(namespace: String!, name: String): IoK8sApiCoreV1PersistentVolumeClaimList
          persistentvolumes(namespace: String!, name: String): IoK8sApiCoreV1PersistentVolumeList
          secrets(namespace: String!, name: String): IoK8sApiCoreV1SecretList
          configmaps(namespace: String!, name: String): IoK8sApiCoreV1ConfigMapList
          no(name: String): IoK8sApiCoreV1NodeList
          ns(name: String): IoK8sApiCoreV1NamespaceList
          sc(name: String): IoK8sApiStorageV1StorageClassList
          csr(name: String): IoK8sApiCertificatesV1beta1CertificateSigningRequestList
          psp(name: String): IoK8sApiPolicyV1beta1PodSecurityPolicyList
          cs(name: String): IoK8sApiCoreV1ComponentStatusList
          crd(name: String): IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList
          pc(name: String): IoK8sApiSchedulingV1PriorityClassList
          po(namespace: String!, name: String): IoK8sApiCoreV1PodList
          svc(namespace: String!, name: String): IoK8sApiCoreV1ServiceList
          rs(namespace: String!, name: String): IoK8sApiAppsV1ReplicaSetList
          deploy(namespace: String!, name: String): IoK8sApiAppsV1DeploymentList
          pvc(namespace: String!, name: String): IoK8sApiCoreV1PersistentVolumeClaimList
          pv(namespace: String!, name: String): IoK8sApiCoreV1PersistentVolumeList
          ing(namespace: String!, name: String): IoK8sApiNetworkingV1beta1IngressClassList
          ds(namespace: String!, name: String): IoK8sApiAppsV1DaemonSetList
          sts(namespace: String!, name: String): IoK8sApiAppsV1StatefulSetList
          rc(namespace: String!, name: String): IoK8sApiCoreV1ReplicationControllerList
          hpa(namespace: String!, name: String): IoK8sApiAutoscalingV1HorizontalPodAutoscalerList
          cj(namespace: String!, name: String): IoK8sApiBatchV1beta1CronJobList
          sa(namespace: String!, name: String): IoK8sApiCoreV1ServiceAccountList
          quota(namespace: String!, name: String): IoK8sApiCoreV1ResourceQuotaList
          ep(namespace: String!, name: String): IoK8sApiCoreV1EndpointsList
          netpol(namespace: String!, name: String): IoK8sApiNetworkingV1NetworkPolicyList
          pdb(namespace: String!, name: String): IoK8sApiPolicyV1beta1PodDisruptionBudgetList
          limits(namespace: String!, name: String): IoK8sApiCoreV1LimitRangeList
          ev(namespace: String!, name: String): IoK8sApiCoreV1EventList
          cm(namespace: String!, name: String): IoK8sApiCoreV1ConfigMapList
        }
    additionalResolvers:
      - ./additional-resolvers.js
        
  example-query.graphql: |-
    query q {
      pods(namespace: "default") {
        items {
          metadata {
            name
          }
          parent {
            parent {
              metadata {
                name
              }
            }
            children {
              items {
                metadata {
                  name
                }
              }
            }
          }
          connected {
            items {
              metadata {
                name
              }
            }
          }
        }
      }
    }
    
  init.sh: |-
    #!/bin/bash
    yarn add deepmerge graphql-fields
    curl -L http://mesh-svc:8001/openapi/v2 -o swagger.json
  additional-resolvers.js: |-
    const graphqlFields = require("graphql-fields");
    const merge = require('deepmerge');

    const resources = {
      nodes: "CoreV1Node",
      namespaces: "CoreV1Namespace",
      clusterrolebindings: "RbacAuthorizationV1ClusterRoleBinding",
      clusterroles: "RbacAuthorizationV1ClusterRole",
      storageclasses: "StorageV1StorageClass",
      mutatingwebhookconfigurations: "AdmissionregistrationV1MutatingWebhookConfiguration",
      validatingwebhookconfigurations: "AdmissionregistrationV1ValidatingWebhookConfiguration",
      certificatesigningrequests: "CertificatesV1beta1CertificateSigningRequest",
      podsecuritypolicies: "PolicyV1beta1PodSecurityPolicy",
      componentstatuses: "CoreV1ComponentStatus",
      customresourcedefinitions: "ApiextensionsV1CustomResourceDefinition",
      priorityclasses: "SchedulingV1PriorityClass",
      csidrivers: "StorageV1CSIDriver",
      csinodes: "StorageV1CSINode",
      volumeattachments: "IoK8sApiStorageV1VolumeAttachment",
      pods: "CoreV1NamespacedPod",
      services: "CoreV1NamespacedService",
      ingresses: "NetworkingV1beta1IngressClass",
      replicasets: "AppsV1NamespacedReplicaSet",
      deployments: "AppsV1NamespacedDeployment",
      statefulsets: "AppsV1NamespacedStatefulSet",
      daemonsets: "AppsV1NamespacedDaemonSet",
      replicationcontrollers: "CoreV1NamespacedReplicationController",
      horizontalpodautoscalers: "AutoscalingV1NamespacedHorizontalPodAutoscaler",
      cronjobs: "BatchV1beta1NamespacedCronJob",
      jobs: "BatchV1beta1NamespacedJob",
      rolebindings: "RbacAuthorizationV1NamespacedRoleBinding",
      roles: "RbacAuthorizationV1NamespacedRole",
      serviceaccounts: "CoreV1NamespacedServiceAccount",
      resourcequotas: "CoreV1NamespacedResourceQuota",
      endpoints: "CoreV1NamespacedEndpoints",
      controllerrevisions: "CoreV1NamespacedEndpoints",
      networkpolicies: "NetworkingV1NamespacedNetworkPolicy",
      poddisruptionbudgets: "PolicyV1beta1NamespacedPodDisruptionBudget",
      limitranges: "CoreV1NamespacedLimitRange",
      podtemplates: "CoreV1NamespacedPodTemplate",
      events: "CoreV1NamespacedEvent",
      persistentvolumeclaims: "CoreV1NamespacedPersistentVolumeClaim",
      persistentvolumes: "CoreV1NamespacedPersistentVolume", 
      secrets: "CoreV1NamespacedSecret",
      configmaps: "CoreV1NamespacedConfigMap"
    };

    const abbreviations = {
      nodes: "no",
      namespaces: "ns",
      storageclasses: "sc",
      certificatesigningrequests: "csr",
      podsecuritypolicies: "psp",
      componentstatuses: "cs",
      customresourcedefinitions: "crd",
      priorityclasses: "pc",
      pods: "po",
      services: "svc",
      replicasets: "rc",
      deployments: "deploy",
      persistentvolumeclaims: "pvc",
      persistentvolumes: "pv",
      ingresses: "ing",
      statefulsets: "sts",
      daemonsets: "ds",
      replicationcontrollers: "rc",
      horizontalpodautoscalers: "hpa",
      cronjobs: "cj",
      serviceaccounts: "sa",
      resourcequotas: "quota",
      endpoints: "ep",
      networkpolicies: "netpol",
      poddisruptionbudgets: "pdb",
      limitranges: "limits",
      events: "ev",
      configmaps: "cm"
    };

    const createParentResolver = (readfn) => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createParentResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var ownerReferences = obj.metadata && obj.metadata.ownerReferences;
        if((!ownerReferences) ||(!ownerReferences.length) || (!namespace)) {
          return null;
        }
        var name = ownerReferences[0].name;
        var _function = graphqlMeshK8s.api[readfn];
        var values = await _function({ name, namespace });
        return values;
      };
      var selectionSet = `{ metadata { name namespace ownerReferences { name }}}`;
      return { resolve, selectionSet };
    }
    const createChildrenResolver = (listfn) => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createChildrenResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var name = obj.metadata && obj.metadata.name;
        if((!name) || (!namespace)) {
          return { items: [] };
        }
        console.log(name, namespace);
        var resolverRequirements = { items: {metadata: { labels: true, ownerReferences: {name: true}}}};
        var mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };
        //console.log(JSON.stringify(mergedFields));
        var _function = graphqlMeshK8s.api[listfn];
        var list = await _function({ namespace }, mergedFields);
        console.log("children base", JSON.stringify(list.items));
        var returnItems = list.items.filter(elem => {
          var ownerReferences = elem.metadata && elem.metadata.ownerReferences;
          if((!ownerReferences) || (!ownerReferences.length)) {
            return false;
          }
          return name == ownerReferences[0].nameStringNonNull; //TOBE: this must be [0].name
        }); 
        list.items = returnItems;
        //console.log(list);
        return list;
      };
      var selectionSet = `{ metadata {name namespace}}`;
      return { resolve, selectionSet };
    }
    const createConnectingResolver = (listfn) => {
      var resolve = async (obj, args, { graphqlMeshK8s }, info) => {
        console.log("createConnectingResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var selector = obj.spec && obj.spec.selector;
        if((!selector) || (!namespace)) {
          console.log("createConnectingResolver FAILED: ", "selector", selector, "namespace", namespace);
          return { items: [] };
        }
        var _function = graphqlMeshK8s.api[listfn];
        //var labelSelector = Object.keys(selector).map(key => key+"="+selector[key]).join(",");
        var resolverRequirements = { items: { metadata: {labels: true}}};
        var mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };
        console.log(JSON.stringify(mergedFields));
        var list = await _function({ namespace }, mergedFields);
        console.log("connecting base", JSON.stringify(list.items));
        //console.log("selector", selector);
        var returnItems = list.items.filter(elem => {
          var labels = elem.metadata.labels;
          return Object.keys(selector).reduce((result, key) => {
            return result && (selector[key] == labels[key])
          }, true)
        });
        list.items = returnItems;
        return list;
      }
      var selectionSet = `{ metadata { name namespace } spec {selector} }`;
      return { resolve, selectionSet };
    }
    const createConnectedResolver = (listfn) => {
      var resolve = async (obj, args, { graphqlMeshK8s }, info) => {
        console.log("createConnectedResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var labels = obj.metadata && obj.metadata.labels;
        if((!labels) || (!namespace)) {
          return { items: [] };
        }
        var _function = graphqlMeshK8s.api[listfn];
        var resolverRequirements = { items: {spec: {selector: true }}};
        var mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };
        var list = await _function({ namespace }, mergedFields);
        console.log("connected base", JSON.stringify(list.items));
        var returnItems = list.items.filter(elem => {
          var selector = elem.spec && elem.spec.selector;
          //console.log("selector", selector);
          if(!selector) {
            return false;
          }
          return Object.keys(selector).reduce((result, key) => {
            return result && (selector[key] == labels[key])
          }, true)
        });
        list.items = returnItems;
        return list;
      }
      var selectionSet = `{ metadata { name namespace labels }}`;
      return { resolve, selectionSet };
    }
    const createMountingResolver = () => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createMountingResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var volumes = obj.spec && obj.spec.volumes;
        if((!volumes) ||(!volumes.length) || (!namespace)) {
          return [];
        }
        var promises = volumes.map(elem => {
          if(elem.configMap) {
            return graphqlMeshK8s.api.readCoreV1NamespacedConfigMap({name: elem.configMap.name, namespace });
          } else if(elem.persistentVolumeClaim) {
            return graphqlMeshK8s.api.readCoreV1NamespacedPersistentVolumeClaim({name: elem.persistentVolumeClaim.claimName, namespace});
          } else if(elem.secret) {
            return graphqlMeshK8s.api.readCoreV1NamespacedSecret({name: elem.secret.secretName, namespace});
          }
        });
        return await Promise.all(promises);
      };
      var selectionSet = `{ metadata { name namespace } spec {volumes {configMap {name} persistentVolumeClaim {claimName} secret {secretName}}}}`;
      return { resolve, selectionSet };
    }
    const createEventResolver = () => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createEventResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var name = obj.metadata && obj.metadata.name;
        var kind = obj.kind;
        //console.log(namespace, name, kind);
        if((!name) /*|| (!kind)*/ || (!namespace)) {
          return { items: [] };
        }
        const resolverRequirements = { items: { involvedObject: { kind: true, name: true }}};
        const mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };
        const events = await graphqlMeshK8s.api.listCoreV1NamespacedEvent({ namespace }, mergedFields);
        var returnEvents = events.items.filter(elem => {
          var involvedObject = elem.involvedObject;
          console.log(involvedObject);
          return (involvedObject.name == name) /*&& (involvedObject.kind == kind)*/;
        });
        events.items = returnEvents;
        return events;
      };
      var selectionSet = `{ kind metadata { namespace name }}`;
      return { resolve, selectionSet };
    }
    const createNamespaceResolver = () => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createNamespaceResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        if(!namespace) {
          return [];
        }
        return await graphqlMeshK8s.api.readCoreV1Namespace({ name: namespace });
      };
      var selectionSet = `{ metadata { namespace }}`;
      return { resolve, selectionSet };
    }
    const createRootResolver = (listfn, readfn) => {
      return async (obj, args, { graphqlMeshK8s }) => {
        if('name' in args) {
          return { items: [await graphqlMeshK8s.api[readfn](args)] };
        }
        return await graphqlMeshK8s.api[listfn](args);
      };
    }

    const resolvers = {
      IoK8sApiCoreV1Pod: {
        parent: createParentResolver("readAppsV1NamespacedReplicaSet"),
        connected: createConnectedResolver("listCoreV1NamespacedService"),
        mounting: createMountingResolver(),
        namespace: createNamespaceResolver(),
        events: createEventResolver()

      },
      IoK8sApiAppsV1ReplicaSet: {
        parent: createParentResolver("readAppsV1NamespacedDeployment"),
        children: createChildrenResolver("listCoreV1NamespacedPod"),
        namespace: createNamespaceResolver(),
        events: createEventResolver()
      },
      IoK8sApiAppsV1Deployment: {
        children: createChildrenResolver("listAppsV1NamespacedReplicaSet"),
        namespace: createNamespaceResolver(),
        events: createEventResolver()
      },
      IoK8sApiCoreV1Service: {
        connecting: createConnectingResolver("listCoreV1NamespacedPod"),
        namespace: createNamespaceResolver(),
        events: createEventResolver()
      },
      K8sResourceInterface: {
        __resolveType(obj, context, info){
          if(obj.kind == "ConfigMap"){
            return 'IoK8sApiCoreV1ConfigMap';
          }
    
          if(obj.kind == "persistentVolumeClaim"){
            return 'IoK8sApiCoreV1PersistentVolumeClaim';
          }
    
          if(obj.kind == "Secret"){
            return 'IoK8sApiCoreV1Secret';
          }
          return null;
        }
      }
    };
    var addonQueryResolver = {};
    for(resource in resources) {
      addonQueryResolver[resource] = createRootResolver("list"+resources[resource], "read"+resources[resource]);
    }
    for(key in abbreviations) {
      addonQueryResolver[abbreviations[key]] = createRootResolver("list"+resources[key], "read"+resources[key]);
    }
    resolvers.Query = addonQueryResolver;
    module.exports = { resolvers };
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: meshrc-cm
  namespace: default
