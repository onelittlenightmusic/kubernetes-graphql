apiVersion: v1
data:
  .meshrc.yaml: |-
    # merger: federation
    sources:
      - name: graphqlMeshK8s
        handler:
          openapi:
            source: /work/swagger.json
            baseUrl: http://mesh-svc:8001/
            skipSchemaValidation: true
        transforms:
          - rename:
              - from: IoK8sApiCoreV1Node
                to: Node
              - from: IoK8sApiCoreV1NodeList
                to: NodeList
              - from: IoK8sApiCoreV1Namespace
                to: Namespace
              - from: IoK8sApiCoreV1NamespaceList
                to: NamespaceList
              - from: IoK8sApiRbacV1ClusterRoleBinding
                to: ClusterRoleBinding
              - from: IoK8sApiRbacV1ClusterRoleBindingList
                to: ClusterRoleBindingList
              - from: IoK8sApiRbacV1ClusterRole
                to: ClusterRole
              - from: IoK8sApiRbacV1ClusterRoleList
                to: ClusterRoleList
              - from: IoK8sApiStorageV1StorageClass
                to: StorageClass
              - from: IoK8sApiStorageV1StorageClassList
                to: StorageClassList
              - from: IoK8sApiAdmissionregistrationV1MutatingWebhookConfiguration
                to: MutatingWebhookConfiguration
              - from: IoK8sApiAdmissionregistrationV1MutatingWebhookConfigurationList
                to: MutatingWebhookConfigurationList
              - from: IoK8sApiAdmissionregistrationV1ValidatingWebhookConfiguration
                to: ValidatingWebhookConfiguration
              - from: IoK8sApiAdmissionregistrationV1ValidatingWebhookConfigurationList
                to: ValidatingWebhookConfigurationList
              - from: IoK8sApiCertificatesV1beta1CertificateSigningRequest
                to: CertificateSigningRequest
              - from: IoK8sApiCertificatesV1beta1CertificateSigningRequestList
                to: CertificateSigningRequestList
              - from: IoK8sApiPolicyV1beta1PodSecurityPolicy
                to: PodSecurityPolicy
              - from: IoK8sApiPolicyV1beta1PodSecurityPolicyList
                to: PodSecurityPolicyList
              - from: IoK8sApiCoreV1ComponentStatus
                to: ComponentStatus
              - from: IoK8sApiCoreV1ComponentStatusList
                to: ComponentStatusList
              - from: IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinition
                to: CustomResourceDefinition
              - from: IoK8sApiextensionsApiserverPkgApisApiextensionsV1CustomResourceDefinitionList
                to: CustomResourceDefinitionList
              - from: IoK8sApiSchedulingV1PriorityClass
                to: PriorityClass
              - from: IoK8sApiSchedulingV1PriorityClassList
                to: PriorityClassList
              - from: IoK8sApiStorageV1CSIDriver
                to: CSIDriver
              - from: IoK8sApiStorageV1CSIDriverList
                to: CSIDriverList
              - from: IoK8sApiStorageV1CSINode
                to: CSINode
              - from: IoK8sApiStorageV1CSINodeList
                to: CSINodeList
              - from: IoK8sApiStorageV1VolumeAttachment
                to: VolumeAttachment
              - from: IoK8sApiStorageV1VolumeAttachmentList
                to: VolumeAttachmentList
              - from: IoK8sApiCoreV1Pod
                to: Pod
              - from: IoK8sApiCoreV1PodList
                to: PodList
              - from: IoK8sApiCoreV1Service
                to: Service
              - from: IoK8sApiCoreV1ServiceList
                to: ServiceList
              - from: IoK8sApiNetworkingV1beta1Ingress
                to: Ingress
              - from: IoK8sApiNetworkingV1beta1IngressList
                to: IngressList
              - from: IoK8sApiAppsV1ReplicaSet
                to: ReplicaSet
              - from: IoK8sApiAppsV1ReplicaSetList
                to: ReplicaSetList
              - from: IoK8sApiAppsV1Deployment
                to: Deployment
              - from: IoK8sApiAppsV1DeploymentList
                to: DeploymentList
              - from: IoK8sApiAppsV1DaemonSet
                to: DaemonSet
              - from: IoK8sApiAppsV1DaemonSetList
                to: DaemonSetList
              - from: IoK8sApiAppsV1StatefulSet
                to: StatefulSet
              - from: IoK8sApiAppsV1StatefulSetList
                to: StatefulSetList
              - from: IoK8sApiCoreV1ReplicationController
                to: ReplicationController
              - from: IoK8sApiCoreV1ReplicationControllerList
                to: ReplicationControllerList
              - from: IoK8sApiAutoscalingV1HorizontalPodAutoscaler
                to: HorizontalPodAutoscaler
              - from: IoK8sApiAutoscalingV1HorizontalPodAutoscalerList
                to: HorizontalPodAutoscalerList
              - from: IoK8sApiBatchV1beta1CronJob
                to: CronJob
              - from: IoK8sApiBatchV1beta1CronJobList
                to: CronJobList
              - from: IoK8sApiBatchV1Job
                to: Job
              - from: IoK8sApiBatchV1JobList
                to: JobList
              - from: IoK8sApiRbacV1RoleBinding
                to: RoleBinding
              - from: IoK8sApiRbacV1RoleBindingList
                to: RoleBindingList
              - from: IoK8sApiRbacV1Role
                to: Role
              - from: IoK8sApiRbacV1RoleList
                to: RoleList
              - from: IoK8sApiCoreV1ServiceAccount
                to: ServiceAccount
              - from: IoK8sApiCoreV1ServiceAccountList
                to: ServiceAccountList
              - from: IoK8sApiCoreV1ResourceQuota
                to: ResourceQuota
              - from: IoK8sApiCoreV1ResourceQuotaList
                to: ResourceQuotaList
              - from: IoK8sApiCoreV1Endpoints
                to: Endpoints
              - from: IoK8sApiCoreV1EndpointsList
                to: EndpointsList
              - from: IoK8sApiAppsV1ControllerRevision
                to: ControllerRevision
              - from: IoK8sApiAppsV1ControllerRevisionList
                to: ControllerRevisionList
              - from: IoK8sApiNetworkingV1NetworkPolicy
                to: NetworkPolicy
              - from: IoK8sApiNetworkingV1NetworkPolicyList
                to: NetworkPolicyList
              - from: IoK8sApiPolicyV1beta1PodDisruptionBudget
                to: PodDisruptionBudget
              - from: IoK8sApiPolicyV1beta1PodDisruptionBudgetList
                to: PodDisruptionBudgetList
              - from: IoK8sApiCoreV1LimitRange
                to: LimitRange
              - from: IoK8sApiCoreV1LimitRangeList
                to: LimitRangeList
              - from: IoK8sApiCoreV1PodTemplate
                to: PodTemplate
              - from: IoK8sApiCoreV1PodTemplateList
                to: PodTemplateList
              - from: IoK8sApiCoreV1Event
                to: Event
              - from: IoK8sApiCoreV1EventList
                to: EventList
              - from: IoK8sApiCoreV1PersistentVolumeClaim
                to: PersistentVolumeClaim
              - from: IoK8sApiCoreV1PersistentVolumeClaimList
                to: PersistentVolumeClaimList
              - from: IoK8sApiCoreV1PersistentVolume
                to: PersistentVolume
              - from: IoK8sApiCoreV1PersistentVolumeList
                to: PersistentVolumeList
              - from: IoK8sApiCoreV1Secret
                to: Secret
              - from: IoK8sApiCoreV1SecretList
                to: SecretList
              - from: IoK8sApiCoreV1ConfigMap
                to: ConfigMap
              - from: IoK8sApiCoreV1ConfigMapList
                to: ConfigMapList

    additionalTypeDefs: |
        interface K8sResourceInterface {
          kind: String
          apiVersion: String
          metadata: IoK8sApimachineryPkgApisMetaV1ObjectMeta
        }
        interface K8sNamespacedResourceInterface {
          namespace: Namespace
        }
        interface K8sEventOwnerInterface {
          events: EventList
        }
        extend type Node implements K8sResourceInterface
        extend type ConfigMap implements K8sResourceInterface
        extend type PersistentVolumeClaim implements K8sResourceInterface
        extend type Secret implements K8sResourceInterface
        union K8sMounted = ConfigMap | PersistentVolume | Secret
        union K8sPodParent = ReplicaSet | DaemonSet | StatefulSet | Node
        extend type Pod implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          parent: K8sPodParent
          connected: ServiceList
          mounting: [K8sMounted]
          namespace: Namespace
          events: EventList
        }
        extend type ReplicaSet implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          parent: Deployment
          children: PodList
          namespace: Namespace
          events: EventList
        }
        extend type Deployment implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          children: ReplicaSetList
          namespace: Namespace
          events: EventList
        }
        extend type Service implements K8sNamespacedResourceInterface & K8sResourceInterface & K8sEventOwnerInterface {
          connecting: PodList
          namespace: Namespace
          events: EventList
        }
        extend type Query {
          # cluster-wide
          nodes(name: String, limit: Int, labelSelector: String): NodeList
          namespaces(name: String, limit: Int, labelSelector: String): NamespaceList
          clusterrolebindings(name: String, limit: Int, labelSelector: String): ClusterRoleBindingList
          clusterroles(name: String, limit: Int, labelSelector: String): ClusterRoleList
          storageclasses(name: String, limit: Int, labelSelector: String): StorageClassList
          mutatingwebhookconfigurations(name: String, limit: Int, labelSelector: String): MutatingWebhookConfigurationList
          validatingwebhookconfigurations(name: String, limit: Int, labelSelector: String): ValidatingWebhookConfigurationList
          certificatesigningrequests(name: String, limit: Int, labelSelector: String): CertificateSigningRequestList
          podsecuritypolicies(name: String, limit: Int, labelSelector: String): PodSecurityPolicyList
          componentstatuses(name: String, limit: Int, labelSelector: String): ComponentStatusList
          customresourcedefinitions(name: String, limit: Int, labelSelector: String): CustomResourceDefinitionList
          priorityclasses(name: String, limit: Int, labelSelector: String): PriorityClassList
          csidrivers(name: String, limit: Int, labelSelector: String): CSIDriverList
          csinodes(name: String, limit: Int, labelSelector: String): CSINodeList
          volumeattachments(name: String, limit: Int, labelSelector: String): VolumeAttachmentList
          # namespaced
          pods(namespace: String!, name: String, limit: Int, labelSelector: String): PodList
          services(namespace: String!, name: String, limit: Int, labelSelector: String): ServiceList
          ingresses(namespace: String!, name: String, limit: Int, labelSelector: String): IngressList
          replicasets(namespace: String!, name: String, limit: Int, labelSelector: String): ReplicaSetList
          deployments(namespace: String!, name: String, limit: Int, labelSelector: String): DeploymentList
          daemonsets(namespace: String!, name: String, limit: Int, labelSelector: String): DaemonSetList
          statefulsets(namespace: String!, name: String, limit: Int, labelSelector: String): StatefulSetList
          replicationcontrollers(namespace: String!, name: String, limit: Int, labelSelector: String): ReplicationControllerList
          horizontalpodautoscalers(namespace: String!, name: String, limit: Int, labelSelector: String): HorizontalPodAutoscalerList
          cronjobs(namespace: String!, name: String, limit: Int, labelSelector: String): CronJobList
          jobs(namespace: String!, name: String, limit: Int, labelSelector: String): JobList
          rolebindings(namespace: String!, name: String, limit: Int, labelSelector: String): RoleBindingList
          roles(namespace: String!, name: String, limit: Int, labelSelector: String): RoleList
          serviceaccounts(namespace: String!, name: String, limit: Int, labelSelector: String): ServiceAccountList
          resourcequotas(namespace: String!, name: String, limit: Int, labelSelector: String): ResourceQuotaList
          endpoints(namespace: String!, name: String, limit: Int, labelSelector: String): EndpointsList
          controllerrevisions(namespace: String!, name: String, limit: Int, labelSelector: String): ControllerRevisionList
          networkpolicies(namespace: String!, name: String, limit: Int, labelSelector: String): NetworkPolicyList
          poddisruptionbudgets(namespace: String!, name: String, limit: Int, labelSelector: String): PodDisruptionBudgetList
          limitranges(namespace: String!, name: String, limit: Int, labelSelector: String): LimitRangeList
          podtemplates(namespace: String!, name: String, limit: Int, labelSelector: String): PodTemplateList
          events(namespace: String!, name: String, limit: Int, labelSelector: String): EventList
          persistentvolumeclaims(namespace: String!, name: String, limit: Int, labelSelector: String): PersistentVolumeClaimList
          persistentvolumes(namespace: String!, name: String, limit: Int, labelSelector: String): PersistentVolumeList
          secrets(namespace: String!, name: String, limit: Int, labelSelector: String): SecretList
          configmaps(namespace: String!, name: String, limit: Int, labelSelector: String): ConfigMapList
          no(name: String, limit: Int, labelSelector: String): NodeList
          ns(name: String, limit: Int, labelSelector: String): NamespaceList
          sc(name: String, limit: Int, labelSelector: String): StorageClassList
          csr(name: String, limit: Int, labelSelector: String): CertificateSigningRequestList
          psp(name: String, limit: Int, labelSelector: String): PodSecurityPolicyList
          cs(name: String, limit: Int, labelSelector: String): ComponentStatusList
          crd(name: String, limit: Int, labelSelector: String): CustomResourceDefinitionList
          pc(name: String, limit: Int, labelSelector: String): PriorityClassList
          po(namespace: String!, name: String, limit: Int, labelSelector: String): PodList
          svc(namespace: String!, name: String, limit: Int, labelSelector: String): ServiceList
          rs(namespace: String!, name: String, limit: Int, labelSelector: String): ReplicaSetList
          deploy(namespace: String!, name: String, limit: Int, labelSelector: String): DeploymentList
          pvc(namespace: String!, name: String, limit: Int, labelSelector: String): PersistentVolumeClaimList
          pv(namespace: String!, name: String, limit: Int, labelSelector: String): PersistentVolumeList
          ing(namespace: String!, name: String, limit: Int, labelSelector: String): IngressList
          ds(namespace: String!, name: String, limit: Int, labelSelector: String): DaemonSetList
          sts(namespace: String!, name: String, limit: Int, labelSelector: String): StatefulSetList
          rc(namespace: String!, name: String, limit: Int, labelSelector: String): ReplicationControllerList
          hpa(namespace: String!, name: String, limit: Int, labelSelector: String): HorizontalPodAutoscalerList
          cj(namespace: String!, name: String, limit: Int, labelSelector: String): CronJobList
          sa(namespace: String!, name: String, limit: Int, labelSelector: String): ServiceAccountList
          quota(namespace: String!, name: String, limit: Int, labelSelector: String): ResourceQuotaList
          ep(namespace: String!, name: String, limit: Int, labelSelector: String): EndpointsList
          netpol(namespace: String!, name: String, limit: Int, labelSelector: String): NetworkPolicyList
          pdb(namespace: String!, name: String, limit: Int, labelSelector: String): PodDisruptionBudgetList
          limits(namespace: String!, name: String, limit: Int, labelSelector: String): LimitRangeList
          ev(namespace: String!, name: String, limit: Int, labelSelector: String): EventList
          cm(namespace: String!, name: String, limit: Int, labelSelector: String): ConfigMapList
        }
    additionalResolvers:
      - ./additional-resolvers.js
        
  example-query.graphql: |-
    query q {
      pods(namespace: "default") {
        items {
          metadata {
            name
          }
          parent {
            parent {
              metadata {
                name
              }
            }
            children {
              items {
                metadata {
                  name
                }
              }
            }
          }
          connected {
            items {
              metadata {
                name
              }
            }
          }
        }
      }
    }
    
  init.sh: |-
    #!/bin/bash
    yarn add deepmerge graphql-fields
    curl -L http://mesh-svc:8001/openapi/v2 -o swagger.json
  additional-resolvers.js: |-
    const graphqlFields = require("graphql-fields");
    const merge = require('deepmerge');

    const resources = {
      nodes: "CoreV1Node",
      namespaces: "CoreV1Namespace",
      clusterrolebindings: "RbacAuthorizationV1ClusterRoleBinding",
      clusterroles: "RbacAuthorizationV1ClusterRole",
      storageclasses: "StorageV1StorageClass",
      mutatingwebhookconfigurations: "AdmissionregistrationV1MutatingWebhookConfiguration",
      validatingwebhookconfigurations: "AdmissionregistrationV1ValidatingWebhookConfiguration",
      certificatesigningrequests: "CertificatesV1beta1CertificateSigningRequest",
      podsecuritypolicies: "PolicyV1beta1PodSecurityPolicy",
      componentstatuses: "CoreV1ComponentStatus",
      customresourcedefinitions: "ApiextensionsV1CustomResourceDefinition",
      priorityclasses: "SchedulingV1PriorityClass",
      csidrivers: "StorageV1CSIDriver",
      csinodes: "StorageV1CSINode",
      volumeattachments: "VolumeAttachment",
      pods: "CoreV1NamespacedPod",
      services: "CoreV1NamespacedService",
      ingresses: "NetworkingV1beta1NamespacedIngress",
      replicasets: "AppsV1NamespacedReplicaSet",
      deployments: "AppsV1NamespacedDeployment",
      statefulsets: "AppsV1NamespacedStatefulSet",
      daemonsets: "AppsV1NamespacedDaemonSet",
      replicationcontrollers: "CoreV1NamespacedReplicationController",
      horizontalpodautoscalers: "AutoscalingV1NamespacedHorizontalPodAutoscaler",
      cronjobs: "BatchV1beta1NamespacedCronJob",
      jobs: "BatchV1beta1NamespacedJob",
      rolebindings: "RbacAuthorizationV1NamespacedRoleBinding",
      roles: "RbacAuthorizationV1NamespacedRole",
      serviceaccounts: "CoreV1NamespacedServiceAccount",
      resourcequotas: "CoreV1NamespacedResourceQuota",
      endpoints: "CoreV1NamespacedEndpoints",
      controllerrevisions: "AppsV1ControllerRevisionList",
      networkpolicies: "NetworkingV1NamespacedNetworkPolicy",
      poddisruptionbudgets: "PolicyV1beta1NamespacedPodDisruptionBudget",
      limitranges: "CoreV1NamespacedLimitRange",
      podtemplates: "CoreV1NamespacedPodTemplate",
      events: "CoreV1NamespacedEvent",
      persistentvolumeclaims: "CoreV1NamespacedPersistentVolumeClaim",
      persistentvolumes: "CoreV1NamespacedPersistentVolume", 
      secrets: "CoreV1NamespacedSecret",
      configmaps: "CoreV1NamespacedConfigMap"
    };

    const abbreviations = {
      nodes: "no",
      namespaces: "ns",
      storageclasses: "sc",
      certificatesigningrequests: "csr",
      podsecuritypolicies: "psp",
      componentstatuses: "cs",
      customresourcedefinitions: "crd",
      priorityclasses: "pc",
      pods: "po",
      services: "svc",
      replicasets: "rc",
      deployments: "deploy",
      persistentvolumeclaims: "pvc",
      persistentvolumes: "pv",
      ingresses: "ing",
      statefulsets: "sts",
      daemonsets: "ds",
      replicationcontrollers: "rc",
      horizontalpodautoscalers: "hpa",
      cronjobs: "cj",
      serviceaccounts: "sa",
      resourcequotas: "quota",
      endpoints: "ep",
      networkpolicies: "netpol",
      poddisruptionbudgets: "pdb",
      limitranges: "limits",
      events: "ev",
      configmaps: "cm"
    };

    const kindmap = {
      Node: "nodes",
      Namespace: "namespaces",
      ClusterRoleBinding: "clusterrolebindings",
      "ClusterRole": "clusterroles",
      StorageClass: "storageclasses",
      MutatingWebhookConfiguration: "mutatingwebhookconfigurations",
      ValidatingWebhookConfiguration: "validatingwebhookconfigurations",
      CertificateSigningRequest: "certificatesigningrequests",
      PodSecurityPolicy: "podsecuritypolicies",
      ComponentStatus: "componentstatuses",
      CustomResourceDefinition: "customresourcedefinitions",
      PriorityClass: "priorityclasses",
      CSIDriver: "csidrivers",
      CSINode: "csinodes",
      VolumeAttachment: "volumeattachments",
      NamespacedPod: "pods",
      Service: "services",
      Ingress: "ingresses",
      ReplicaSet: "replicasets",
      Deployment: "deployments",
      StatefulSet: "statefulsets",
      DaemonSet: "daemonsets",
      ReplicationController: "replicationcontrollers",
      HorizontalPodAutoscale: "horizontalpodautoscalers",
      CronJob: "cronjobs",
      Job: "jobs",
      RoleBinding: "rolebindings",
      Role: "roles",
      ServiceAccount: "serviceaccounts",
      ResourceQuota: "resourcequotas",
      Endpoints: "endpoints",
      ControllerRevisionList: "controllerrevisions",
      NetworkPolicy: "networkpolicies",
      PodDisruptionBudget: "poddisruptionbudgets",
      LimitRange: "limitranges",
      PodTemplate: "podtemplates",
      Event: "events",
      PersistentVolumeClaim: "persistentvolumeclaims",
      PersistentVolume: "persistentvolumes", 
      Secret: "secrets",
      ConfigMap: "configmaps"
    }

    const getListFuncName = resource => "list"+resources[resource];
    const getReadFuncName = resource => "read"+resources[resource];
    const getReadFuncNameFromKind = kind => getReadFuncName(kindmap[kind]);

    const createParentResolver = (resourcelist) => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createParentResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var ownerReferences = obj.metadata && obj.metadata.ownerReferences;
        if((!ownerReferences) ||(!ownerReferences.length) || (!namespace)) {
          return null;
        }
        var name = ownerReferences[0].name;
        const kind = ownerReferences[0].kind;
        const readfn = getReadFuncNameFromKind(kind);
        var _function = graphqlMeshK8s.api[readfn];
        var values = await _function({ name, namespace });
        return values;
      };
      var selectionSet = `{ metadata { name namespace ownerReferences { name kind }}}`;
      return { resolve, selectionSet };
    }
    const createChildrenResolver = (resource) => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createChildrenResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var name = obj.metadata && obj.metadata.name;
        if((!name) || (!namespace)) {
          return { items: [] };
        }
        console.log(name, namespace);
        var resolverRequirements = { items: {metadata: { labels: true, ownerReferences: {name: true}}}};
        var mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };
        //console.log(JSON.stringify(mergedFields));

        const listfn = getListFuncName(resource);
        var _function = graphqlMeshK8s.api[listfn];
        var list = await _function({ namespace }, mergedFields);
        console.log("children base", JSON.stringify(list.items));
        var returnItems = list.items.filter(elem => {
          var ownerReferences = elem.metadata && elem.metadata.ownerReferences;
          if((!ownerReferences) || (!ownerReferences.length)) {
            return false;
          }
          return name == ownerReferences[0].nameStringNonNull; //TOBE: this must be [0].name
        }); 
        list.items = returnItems;
        //console.log(list);
        return list;
      };
      var selectionSet = `{ metadata {name namespace}}`;
      return { resolve, selectionSet };
    }
    const createConnectingResolver = (resource) => {
      var resolve = async (obj, args, { graphqlMeshK8s }, info) => {
        console.log("createConnectingResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var selector = obj.spec && obj.spec.selector;
        if((!selector) || (!namespace)) {
          console.log("createConnectingResolver FAILED: ", "selector", selector, "namespace", namespace);
          return { items: [] };
        }

        const listfn = getListFuncName(resource);
        var _function = graphqlMeshK8s.api[listfn];
        //var labelSelector = Object.keys(selector).map(key => key+"="+selector[key]).join(",");
        var resolverRequirements = { items: { metadata: {labels: true}}};
        var mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };
        console.log(JSON.stringify(mergedFields));
        var list = await _function({ namespace }, mergedFields);
        console.log("connecting base", JSON.stringify(list.items));
        //console.log("selector", selector);
        var returnItems = list.items.filter(elem => {
          var labels = elem.metadata.labels;
          return Object.keys(selector).reduce((result, key) => {
            return result && (selector[key] == labels[key])
          }, true)
        });
        list.items = returnItems;
        return list;
      }
      var selectionSet = `{ metadata { name namespace } spec {selector} }`;
      return { resolve, selectionSet };
    }
    const createConnectedResolver = (resource) => {
      var resolve = async (obj, args, { graphqlMeshK8s }, info) => {
        console.log("createConnectedResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var labels = obj.metadata && obj.metadata.labels;
        if((!labels) || (!namespace)) {
          return { items: [] };
        }

        const listfn = getListFuncName(resource);
        var _function = graphqlMeshK8s.api[listfn];
        var resolverRequirements = { items: {spec: {selector: true }}};
        var mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };
        var list = await _function({ namespace }, mergedFields);
        console.log("connected base", JSON.stringify(list.items));
        var returnItems = list.items.filter(elem => {
          var selector = elem.spec && elem.spec.selector;
          //console.log("selector", selector);
          if(!selector) {
            return false;
          }
          return Object.keys(selector).reduce((result, key) => {
            return result && (selector[key] == labels[key])
          }, true)
        });
        list.items = returnItems;
        return list;
      }
      var selectionSet = `{ metadata { name namespace labels }}`;
      return { resolve, selectionSet };
    }
    const createMountingResolver = () => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createMountingResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var volumes = obj.spec && obj.spec.volumes;
        if((!volumes) ||(!volumes.length) || (!namespace)) {
          return [];
        }
        var promises = volumes.map(elem => {
          if(elem.configMap) {
            return graphqlMeshK8s.api.readCoreV1NamespacedConfigMap({name: elem.configMap.name, namespace });
          } else if(elem.persistentVolumeClaim) {
            return graphqlMeshK8s.api.readCoreV1NamespacedPersistentVolumeClaim({name: elem.persistentVolumeClaim.claimName, namespace});
          } else if(elem.secret) {
            return graphqlMeshK8s.api.readCoreV1NamespacedSecret({name: elem.secret.secretName, namespace});
          }
        }).filter(elem => elem != null);
        return await Promise.all(promises);
      };
      var selectionSet = `{ metadata { name namespace } spec {volumes {configMap {name} persistentVolumeClaim {claimName} secret {secretName}}}}`;
      return { resolve, selectionSet };
    }
    const createEventResolver = () => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createEventResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var name = obj.metadata && obj.metadata.name;
        var kind = obj.kind;
        //console.log(namespace, name, kind);
        if((!name) /*|| (!kind)*/ || (!namespace)) {
          return { items: [] };
        }
        const resolverRequirements = { items: { involvedObject: { kind: true, name: true }}};
        const mergedFields = { fields: merge(graphqlFields(info), resolverRequirements) };
        const events = await graphqlMeshK8s.api.listCoreV1NamespacedEvent({ namespace }, mergedFields);
        var returnEvents = events.items.filter(elem => {
          var involvedObject = elem.involvedObject;
          console.log(involvedObject);
          return (involvedObject.name == name) /*&& (involvedObject.kind == kind)*/;
        });
        events.items = returnEvents;
        return events;
      };
      var selectionSet = `{ kind metadata { namespace name }}`;
      return { resolve, selectionSet };
    }
    const createNamespaceResolver = () => {
      var resolve = async (obj, args, {graphqlMeshK8s}, info) => {
        console.log("createNamespaceResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        if(!namespace) {
          return [];
        }
        return await graphqlMeshK8s.api.readCoreV1Namespace({ name: namespace });
      };
      var selectionSet = `{ metadata { namespace }}`;
      return { resolve, selectionSet };
    }

    const createRootResolver = (listfn, readfn) => {
      return async (obj, args, { graphqlMeshK8s }) => {
        if('name' in args) {
          return { items: [await graphqlMeshK8s.api[readfn](args)] };
        }
        return await graphqlMeshK8s.api[listfn](args);
      };
    }

    const resolvers = {
      Pod: {
        parent: createParentResolver("replicasets"),
        connected: createConnectedResolver("services"),
        mounting: createMountingResolver(),
        namespace: createNamespaceResolver(),
        events: createEventResolver()

      },
      ReplicaSet: {
        parent: createParentResolver("deployments"),
        children: createChildrenResolver("pods"),
        namespace: createNamespaceResolver(),
        events: createEventResolver()
      },
      Deployment: {
        children: createChildrenResolver("replicasets"),
        namespace: createNamespaceResolver(),
        events: createEventResolver()
      },
      Service: {
        connecting: createConnectingResolver("pods"),
        namespace: createNamespaceResolver(),
        events: createEventResolver()
      },
      K8sMounted: {
        __resolveType(obj, context, info){
          if(obj.kind == "ConfigMap"){
            return 'ConfigMap';
          }

          if(obj.kind == "PersistentVolumeClaim"){
            return 'PersistentVolumeClaim';
          }

          if(obj.kind == "Secret"){
            return 'Secret';
          }
          return null;
        }
      },
      K8sPodParent: {
        __resolveType(obj, context, info){
          if(obj.kind == "ReplicaSet"){
            return 'ReplicaSet';
          }

          if(obj.kind == "DaemonSet"){
            return 'DaemonSet';
          }

          if(obj.kind == "StatefulSet"){
            return 'StatefulSet';
          }

          if(obj.kind == "Node"){
            return 'Node';
          }
          return null;
        }
      }
    };
    var addonQueryResolver = {};
    for(resource in resources) {
      addonQueryResolver[resource] = createRootResolver(getListFuncName(resource), getReadFuncName(resource));
    }
    for(key in abbreviations) {
      addonQueryResolver[abbreviations[key]] = createRootResolver("list"+resources[key], "read"+resources[key]);
    }
    resolvers.Query = addonQueryResolver;
    module.exports = { resolvers };
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: meshrc-cm
  namespace: default
