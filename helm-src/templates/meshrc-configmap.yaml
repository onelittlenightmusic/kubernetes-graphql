{{- $subchart := "kubernetes-api-proxy" -}}
{{- $newContext := (dict "Chart" (dict "Name" $subchart) "Values" (index .Values $subchart) "Release" .Release "Capabilities" .Capabilities)}}
apiVersion: v1
data:
  .meshrc.yaml: |-
    # merger: federation
    sources:
      - name: graphqlMeshK8s
        handler:
          openapi:
            source: /work/swagger.json
            baseUrl: http://{{- include "kubernetes-api-proxy.fullname" $newContext -}}:8001/
            skipSchemaValidation: true
        # transforms:
        # - federation: 
        #     types:
        #     - name: Query
        #       config:
        #         extend: true
        #     - name: IoK8sCoreV1Pod
        #       config:
        #         extend: true
        #         keyFields:
        #             - metadata.name
        #         resolveReference: ./childResolveReference.js
    additionalTypeDefs: |
      extend type IoK8sApiCoreV1Pod {
        parent: IoK8sApiAppsV1ReplicaSet
        connected: [IoK8sApiCoreV1Service]
      }
      extend type IoK8sApiAppsV1ReplicaSet {
        parent: IoK8sApiAppsV1Deployment
        children: [IoK8sApiCoreV1Pod]
      }
      extend type IoK8sApiAppsV1Deployment {
        children: [IoK8sApiAppsV1ReplicaSet]
      }
      extend type IoK8sApiCoreV1Service {
        connecting: [IoK8sApiCoreV1Pod]
      }
    additionalResolvers:
      - ./additional-resolvers.js
        
  example-query.graphql: |-
    query q {
      listCoreV1NamespacedPod(namespace: "default") {
        items {
          metadata {
            name
            namespace
            ownerReferences {
              name
            }
            labels
          }
          parent {
            parent {
              metadata {
                name
              }
            }
            children {
              metadata {
                name
              }
            }
          }
          connected {
            metadata {
              name
            }
          }
        }
      }
    }
    
    
  init.sh: |-
    #!/bin/bash
    curl -L http://{{- include "kubernetes-api-proxy.fullname" $newContext -}}:8001/openapi/v2 -o swagger.json
  additional-resolvers.js: |-
    const createParentResolver = (readfn) => {
      var resolve = async (obj, args, { graphqlMeshK8s }) => {
        console.log("createParentResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var ownerReferences = obj.metadata && obj.metadata.ownerReferences;
        if((!ownerReferences) ||(!ownerReferences.length) || (!namespace)) {
          return null;
        }
        var name = ownerReferences[0].name;
        var _function = graphqlMeshK8s.api[readfn]
        return _function({ name, namespace })
      };
      return { resolve };
    }
    const createChildrenResolver = (listfn) => {
      var resolve = async (obj, args, {graphqlMeshK8s}) => {
        console.log("createChildrenResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var name = obj.metadata && obj.metadata.name;
        if((!name) || (!namespace)) {
          return null;
        }
        var _function = graphqlMeshK8s.api[listfn];
        var list = await _function({ namespace });
        return list.items.filter(elem => {
          var ownerReferences = elem.metadata && elem.metadata.ownerReferences;
          if((!ownerReferences) || (!ownerReferences.length)) {
            return false;
          }
          return name == ownerReferences[0].name;
        });
      };
      return { resolve };
    }
    const createConnectingResolver = (listfn) => {
      var resolve = async (obj, args, { graphqlMeshK8s }) => {
        console.log("createConnectingResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var selector = obj.spec && obj.spec.selector;
        if((!selector) || (!namespace)) {
          return [];
        }
        var _function = graphqlMeshK8s.api[listfn];
        var list = await _function({ namespace });
        //console.log("selector", selector);
        return list.items.filter(elem => {
          var labels = elem.metadata.labels;
          return Object.keys(selector).reduce((result, key) => {
            return result && (selector[key] == labels[key])
          }, true)
        })
      }
      return { resolve };
    }
    const createConnectedResolver = (listfn) => {
      var resolve = async (obj, args, { graphqlMeshK8s }) => {
        console.log("createConnectedResolver");
        var namespace = obj.metadata && obj.metadata.namespace;
        var labels = obj.metadata && obj.metadata.labels;
        if((!labels) || (!namespace)) {
          return [];
        }
        var _function = graphqlMeshK8s.api[listfn];
        var list = await _function({ namespace });
        return list.items.filter(elem => {
          var selector = elem.spec && elem.spec.selector;
          //console.log("selector", selector);
          if(!selector) {
            return false;
          }
          return Object.keys(selector).reduce((result, key) => {
            return result && (selector[key] == labels[key])
          }, true)
        })
      }
      return { resolve };
    }
    const resolvers = {
      IoK8sApiCoreV1Pod: {
        parent: createParentResolver("readAppsV1NamespacedReplicaSet"),
        connected: createConnectedResolver("listCoreV1NamespacedService")
      },
      IoK8sApiAppsV1ReplicaSet: {
        parent: createParentResolver("readAppsV1NamespacedDeployment"),
        children: createChildrenResolver("listCoreV1NamespacedPod")
      },
      IoK8sApiAppsV1Deployment: {
        children: createChildrenResolver("listAppsV1NamespacedReplicaSet")
      },
      IoK8sApiCoreV1Service: {
        connecting: createConnectingResolver("listCoreV1NamespacedPod")
      }
    };
    module.exports = { resolvers };
  # childResolveReference.js: |-
  #   module.exports = (root, context) => context.graphqlMeshK8s.api.readAppsV1NamespacedReplicaSet({ name: root.metadata.name })
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: meshrc
